#!/usr/bin/env bash
set -euo pipefail

BASHCLAW_VERSION="1.0.0"
BASHCLAW_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BASHCLAW_STATE_DIR="${BASHCLAW_STATE_DIR:-${HOME}/.bashclaw}"

export BASHCLAW_VERSION BASHCLAW_ROOT BASHCLAW_STATE_DIR

# Source library modules
for _lib in "${BASHCLAW_ROOT}"/lib/*.sh; do
  [[ -f "$_lib" ]] && source "$_lib"
done
unset _lib

usage() {
  cat <<EOF
bashclaw v${BASHCLAW_VERSION} - Bash-native AI agent framework

Usage: bashclaw <command> [options]

Commands:
  agent       Manage agents (start, stop, list, logs)
  gateway     Start/stop the HTTP gateway
  daemon      Manage system service (install, status, logs)
  message     Send a message to an agent
  config      Manage configuration
  session     Manage conversation sessions
  memory      Manage persistent key-value memory
  cron        Manage scheduled jobs
  hooks       Manage event hooks
  boot        Run or check agent boot sequence
  security    Security policy and pairing management
  onboard     Interactive setup wizard
  status      Show system status
  doctor      Run diagnostics
  update      Update bashclaw to latest version
  completion  Generate shell completion scripts
  version     Show version info

Options:
  -h, --help      Show this help
  -v, --version   Show version

Environment:
  BASHCLAW_STATE_DIR   State directory (default: ~/.bashclaw)
  BASHCLAW_CONFIG      Config file path override
  LOG_LEVEL            Log level: debug|info|warn|error|fatal|silent
  MODEL_ID             Default model ID

EOF
}

cmd_version() {
  printf 'bashclaw %s\n' "$BASHCLAW_VERSION"
}

cmd_update() {
  local install_dir="$BASHCLAW_ROOT"

  if [[ -d "${install_dir}/.git" ]]; then
    log_info "Updating via git pull..."
    (cd "$install_dir" && git pull --ff-only)
    if [[ $? -eq 0 ]]; then
      printf 'Updated to latest version.\n'
    else
      log_error "Git pull failed"
      return 1
    fi
  elif [[ -f "${install_dir}/../install.sh" ]]; then
    log_info "Re-running installer..."
    bash "${install_dir}/../install.sh"
  else
    log_error "Cannot determine installation method. Please re-run the installer."
    return 1
  fi
}

cmd_completion() {
  local shell_type="${1:-bash}"

  case "$shell_type" in
    bash) _completion_bash ;;
    zsh)  _completion_zsh ;;
    *)
      log_error "Unknown shell: $shell_type (supported: bash, zsh)"
      return 1
      ;;
  esac
}

_completion_bash() {
  cat <<'COMP'
_bashclaw() {
  local cur prev commands subcommands
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  commands="agent gateway daemon message config session memory cron hooks boot security onboard status doctor update completion version help"

  case "$prev" in
    bashclaw)
      COMPREPLY=($(compgen -W "$commands" -- "$cur"))
      ;;
    agent)
      COMPREPLY=($(compgen -W "-m --message -a --agent -i --interactive -v --verbose -h --help" -- "$cur"))
      ;;
    gateway)
      COMPREPLY=($(compgen -W "-p --port -v --verbose -d --daemon --stop -h --help" -- "$cur"))
      ;;
    daemon)
      COMPREPLY=($(compgen -W "install uninstall status logs restart stop" -- "$cur"))
      ;;
    config)
      COMPREPLY=($(compgen -W "show get set init validate edit path" -- "$cur"))
      ;;
    session)
      COMPREPLY=($(compgen -W "list show clear delete export" -- "$cur"))
      ;;
    memory)
      COMPREPLY=($(compgen -W "list search get set delete export import compact stats" -- "$cur"))
      ;;
    cron)
      COMPREPLY=($(compgen -W "list add remove enable disable run history" -- "$cur"))
      ;;
    hooks)
      COMPREPLY=($(compgen -W "list add remove enable disable test" -- "$cur"))
      ;;
    boot)
      COMPREPLY=($(compgen -W "run find status reset" -- "$cur"))
      ;;
    security)
      COMPREPLY=($(compgen -W "pair-generate pair-verify tool-check elevated-check audit" -- "$cur"))
      ;;
    message)
      COMPREPLY=($(compgen -W "send" -- "$cur"))
      ;;
    completion)
      COMPREPLY=($(compgen -W "bash zsh" -- "$cur"))
      ;;
  esac
}
complete -F _bashclaw bashclaw
COMP
}

_completion_zsh() {
  cat <<'COMP'
#compdef bashclaw

_bashclaw() {
  local -a commands
  commands=(
    'agent:Manage agents'
    'gateway:Start/stop the HTTP gateway'
    'daemon:Manage system service'
    'message:Send a message to an agent'
    'config:Manage configuration'
    'session:Manage conversation sessions'
    'memory:Manage persistent memory'
    'cron:Manage scheduled jobs'
    'hooks:Manage event hooks'
    'boot:Run or check agent boot sequence'
    'security:Security policy and pairing management'
    'onboard:Interactive setup wizard'
    'status:Show system status'
    'doctor:Run diagnostics'
    'update:Update bashclaw'
    'completion:Generate shell completions'
    'version:Show version info'
    'help:Show help'
  )

  _arguments '1:command:->command' '*::arg:->args'

  case "$state" in
    command)
      _describe 'command' commands
      ;;
    args)
      case "${words[1]}" in
        daemon)
          _values 'subcommand' install uninstall status logs restart stop
          ;;
        config)
          _values 'subcommand' show get set init validate edit path
          ;;
        session)
          _values 'subcommand' list show clear delete export
          ;;
        memory)
          _values 'subcommand' list search get set delete export import compact stats
          ;;
        cron)
          _values 'subcommand' list add remove enable disable run history
          ;;
        hooks)
          _values 'subcommand' list add remove enable disable test
          ;;
        boot)
          _values 'subcommand' run find status reset
          ;;
        security)
          _values 'subcommand' pair-generate pair-verify tool-check elevated-check audit
          ;;
        message)
          _values 'subcommand' send
          ;;
        completion)
          _values 'shell' bash zsh
          ;;
      esac
      ;;
  esac
}

_bashclaw "$@"
COMP
}

cmd_status() {
  printf '=== bashclaw status ===\n'
  printf 'Version:    %s\n' "$BASHCLAW_VERSION"
  printf 'State dir:  %s\n' "$BASHCLAW_STATE_DIR"
  printf 'Config:     %s\n' "$(config_path)"

  if [[ -f "$(config_path)" ]]; then
    printf 'Config:     found\n'
  else
    printf 'Config:     not found\n'
  fi

  local gw_port
  gw_port="$(config_get '.gateway.port' '18789')"
  if ! is_port_available "$gw_port"; then
    printf 'Gateway:    running (port %s)\n' "$gw_port"
  else
    printf 'Gateway:    stopped\n'
  fi

  local session_count=0
  local session_dir="${BASHCLAW_STATE_DIR}/sessions"
  if [[ -d "$session_dir" ]]; then
    session_count="$(find "$session_dir" -name '*.jsonl' 2>/dev/null | wc -l | tr -d ' ')"
  fi
  printf 'Sessions:   %s\n' "$session_count"
}

cmd_doctor() {
  local issues=0
  printf '=== bashclaw doctor ===\n\n'

  # Check required commands
  local cmds=(bash jq curl)
  for cmd in "${cmds[@]}"; do
    if is_command_available "$cmd"; then
      printf '[OK]   %s found: %s\n' "$cmd" "$(command -v "$cmd")"
    else
      printf '[FAIL] %s not found\n' "$cmd"
      issues=$((issues + 1))
    fi
  done

  # Check optional commands
  local opt_cmds=(python3 uuidgen socat nc)
  for cmd in "${opt_cmds[@]}"; do
    if is_command_available "$cmd"; then
      printf '[OK]   %s found (optional)\n' "$cmd"
    else
      printf '[WARN] %s not found (optional)\n' "$cmd"
    fi
  done

  printf '\n'

  # Check state directory
  if [[ -d "$BASHCLAW_STATE_DIR" ]]; then
    printf '[OK]   State dir exists: %s\n' "$BASHCLAW_STATE_DIR"
  else
    printf '[WARN] State dir missing: %s\n' "$BASHCLAW_STATE_DIR"
  fi

  # Check config
  local cfg_path
  cfg_path="$(config_path)"
  if [[ -f "$cfg_path" ]]; then
    printf '[OK]   Config found: %s\n' "$cfg_path"
    if config_validate; then
      printf '[OK]   Config is valid JSON\n'
    else
      printf '[FAIL] Config validation failed\n'
      issues=$((issues + 1))
    fi
  else
    printf '[WARN] No config file (run: bashclaw config init)\n'
  fi

  # Check API key
  if [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
    printf '[OK]   ANTHROPIC_API_KEY is set\n'
  else
    printf '[WARN] ANTHROPIC_API_KEY not set\n'
  fi

  printf '\n'
  if (( issues > 0 )); then
    printf 'Found %d issue(s)\n' "$issues"
    return 1
  else
    printf 'All checks passed\n'
    return 0
  fi
}

cmd_boot() {
  local subcmd="${1:-status}"
  shift || true

  case "$subcmd" in
    run)
      local agent_id="${1:-main}"
      boot_auto "$agent_id"
      ;;
    find)
      local agent_id="${1:-main}"
      local found
      found="$(boot_find "$agent_id" 2>/dev/null)" && {
        printf 'BOOT.md found: %s\n' "$found"
      } || {
        printf 'No BOOT.md found for agent: %s\n' "$agent_id"
      }
      ;;
    status)
      local agent_id="${1:-}"
      boot_status "$agent_id"
      ;;
    reset)
      local agent_id="${1:-}"
      boot_reset "$agent_id"
      ;;
    *)
      printf 'Usage: bashclaw boot <run|find|status|reset> [agent_id]\n'
      ;;
  esac
}

cmd_security() {
  local subcmd="${1:-}"
  shift || true

  case "$subcmd" in
    pair-generate)
      local channel="${1:?channel required}"
      local sender="${2:?sender required}"
      local code
      code="$(security_pairing_code_generate "$channel" "$sender")"
      printf 'Pairing code: %s\n' "$code"
      ;;
    pair-verify)
      local channel="${1:?channel required}"
      local sender="${2:?sender required}"
      local code="${3:?code required}"
      if security_pairing_code_verify "$channel" "$sender" "$code"; then
        printf 'Pairing verified.\n'
      else
        printf 'Pairing failed.\n'
        return 1
      fi
      ;;
    tool-check)
      local agent_id="${1:?agent_id required}"
      local tool_name="${2:?tool_name required}"
      local session_type="${3:-main}"
      if security_tool_policy_check "$agent_id" "$tool_name" "$session_type"; then
        printf 'Tool allowed: %s for agent %s (session: %s)\n' "$tool_name" "$agent_id" "$session_type"
      else
        printf 'Tool denied: %s for agent %s (session: %s)\n' "$tool_name" "$agent_id" "$session_type"
        return 1
      fi
      ;;
    elevated-check)
      local tool_name="${1:?tool_name required}"
      local sender="${2:-}"
      local channel="${3:-}"
      local result
      result="$(security_elevated_check "$tool_name" "$sender" "$channel")"
      printf '%s\n' "$result"
      ;;
    audit)
      local audit_file="${BASHCLAW_STATE_DIR}/logs/audit.jsonl"
      if [[ -f "$audit_file" ]]; then
        local lines="${1:-20}"
        tail -n "$lines" "$audit_file"
      else
        printf 'No audit log found.\n'
      fi
      ;;
    *)
      printf 'Usage: bashclaw security <pair-generate|pair-verify|tool-check|elevated-check|audit> [args]\n'
      ;;
  esac
}

# Route to sub-commands
main() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    agent)
      cmd_agent "$@"
      ;;
    gateway)
      cmd_gateway "$@"
      ;;
    daemon)
      cmd_daemon "$@"
      ;;
    message|msg)
      cmd_message "$@"
      ;;
    config|cfg)
      cmd_config "$@"
      ;;
    session|sess)
      cmd_session "$@"
      ;;
    memory|mem)
      cmd_memory "$@"
      ;;
    cron)
      cmd_cron "$@"
      ;;
    hooks)
      cmd_hooks "$@"
      ;;
    boot)
      cmd_boot "$@"
      ;;
    security|sec)
      cmd_security "$@"
      ;;
    onboard|setup)
      cmd_onboard "$@"
      ;;
    status)
      cmd_status
      ;;
    doctor)
      cmd_doctor
      ;;
    update)
      cmd_update
      ;;
    completion)
      cmd_completion "$@"
      ;;
    version|-v|--version)
      cmd_version
      ;;
    help|-h|--help|"")
      usage
      ;;
    *)
      log_error "Unknown command: $cmd"
      usage
      exit 1
      ;;
  esac
}

main "$@"
